# 内存分页机制

## 各种地址的区别

- 逻辑地址：程序访问的地址
- 线性地址：程序访问的地址 + 描述符中的基地址
- 物理地址：实际内存的位置

  平坦模型（就是将4G内存全部映射到一个段）中，逻辑地址和线性地址是相同的；

- 虚拟地址：线性地址经过分页机制转换后的地址。

## 内存分页

```c++
// 页目录项/页表项
typedef struct page_entry_t
{
    u8 present : 1;  // 在内存中
    u8 write : 1;    // 0 只读 1 可读可写
    u8 user : 1;     // 1 所有人 0 超级用户 DPL < 3
    u8 pwt : 1;      // page write through 1 直写模式，0 回写模式
    // 直写: 立即将修改的缓存块写回内存, 缺点是每次写都会引起总线流量
    // 回写: 当被修改的块被换出时再写回内存, 缺点是增加复杂性, 需要维护一个修改位

    // 在回写模式下，当缓存块被修改时，更改不会立即写回内存。相反，缓存控制器会将修改过的缓存块标记为“脏”（dirty），并在稍后的某个时间将其写回内存。这个时间点通常是当缓存控制器需要为新的数据腾出空间时，它会选择一个脏块并将其写回内存，然后再使用该块来存储新的数据。

    u8 pcd : 1;      // page cache disable 禁止该页缓冲到cache中
    u8 accessed : 1; // 被访问过，用于统计使用频率
    u8 dirty : 1;    // 脏页，表示该页缓冲被写过，用于置换到磁盘的时候判断是否需要更新磁盘中的内容
    u8 pat : 1;      // page attribute table 页大小 4K/4M，80386只支持4K页
    u8 global : 1;   // 全局，所有进程都用到了，该页不刷新缓冲
    u8 ignored : 3;  // 该安排的都安排了，送给操作系统吧
    u32 index : 20;  // 页索引
} _packed page_entry_t;
```

初始化页表项的时候我们暂时只关心present/write/user/index这几个字段，其他字段暂时不用管。

```c++
// 初始化页表项/页目录项
static void entry_init(page_entry_t *entry, u32 index)
{
    *(u32 *)entry = 0;
    entry->present = 1;
    entry->write = 1;
    entry->user = 1;
    entry->index = index;
}
```

## 内存映射

CR3寄存器用于存放页目录表的物理地址

CR0的PG位（最高位）用于开启分页机制
