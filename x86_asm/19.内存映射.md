# 内存映射

虚拟内存映射

- 可以支持虚拟内存 / 使用硬盘模拟内存
- 可以支持多进程访问同一个内存地址

虚拟地址/线性地址 <-> 物理地址 的映射

## 内存分页

32位的地址 -> 4G的内存 -> 4kB的页。可以将4G的内存分成 4G / 4kB = 1M 个页。

## 页表

```c
// 单级页表
// 每个进程都需要1M * 4B = 4MB存储页表，也就是需要4MB / 4kB = 1024个页存储页表
unsigned int page_table[1 << 20];

// 优化：使用页目录存储哪些页用来存储页表了
unsigned int page_dir[1024];

```

## 页表的信息

由于page_table只需要2的20次方存储索引，所以可以将页表的信息放在索引的高12位。


```c
struct page_entry {
    uint8_t present: 1; // 页是否存在
    uint8_t write: 1;   // 0: 只读，1: 可读写
    uint8_t user: 1;    // 0: 内核，特权级3不可访问，1: 用户
    uint8_t pwt: 1;     // 1 页通写，表示该页需要高速缓存 / 置为0即可
    uint8_t pcd: 1;     // 1 页禁止缓存 / 置为0即可
    uint8_t accessed: 1;// 1 页被CPU访问过 / 用来统计页的使用频率
    uint8_t dirty: 1;   // 1 脏位 / 被写过会置为1
    uint8_t pat: 1;     // 1 页属性表 / 置为0即可
    uint8_t global: 1;  // 1 全局位，应该放在块表中 / 在操作系统中引入快表是为了加快地址映射速度。
    uint8_t avail: 3;   // 保留位
    uint32_t index: 20; // 页表索引 或者是 物理页地址的高20位！！！！
}

